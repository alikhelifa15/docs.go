---
title: Packages
description: Organisation du code, imports, go modules et cr√©ation de packages
---

# Packages en Go

Les packages sont la fa√ßon dont Go organise et structure le code. Ils permettent de grouper des fonctionnalit√©s li√©es et de cr√©er des programmes modulaires et r√©utilisables.

## Concepts de base

### Qu'est-ce qu'un package ?
```go
// Chaque fichier Go commence par une d√©claration de package
package main  // Package ex√©cutable

package utils  // Package de biblioth√®que

package models  // Package pour les mod√®les de donn√©es
```

### Rules des packages
- **Un r√©pertoire = un package** (tous les fichiers `.go` d'un r√©pertoire appartiennent au m√™me package)
- **Package `main`** : point d'entr√©e des programmes ex√©cutables
- **Autres packages** : biblioth√®ques r√©utilisables
- **Noms en minuscules** : convention pour les noms de packages

## Organisation d'un projet

### Structure recommand√©e
```
monprojet/
‚îú‚îÄ‚îÄ go.mod                 # D√©finition du module
‚îú‚îÄ‚îÄ go.sum                 # Hashes des d√©pendances
‚îú‚îÄ‚îÄ main.go                # Point d'entr√©e
‚îú‚îÄ‚îÄ cmd/                   # Applications ex√©cutables
‚îÇ   ‚îú‚îÄ‚îÄ serveur/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ main.go
‚îÇ   ‚îî‚îÄ‚îÄ client/
‚îÇ       ‚îî‚îÄ‚îÄ main.go
‚îú‚îÄ‚îÄ internal/              # Code priv√© au projet
‚îÇ   ‚îú‚îÄ‚îÄ auth/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.go
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ auth_test.go
‚îÇ   ‚îî‚îÄ‚îÄ database/
‚îÇ       ‚îú‚îÄ‚îÄ database.go
‚îÇ       ‚îî‚îÄ‚îÄ models.go
‚îú‚îÄ‚îÄ pkg/                   # Code r√©utilisable publiquement
‚îÇ   ‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ strings.go
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ math.go
‚îÇ   ‚îî‚îÄ‚îÄ api/
‚îÇ       ‚îî‚îÄ‚îÄ client.go
‚îú‚îÄ‚îÄ web/                   # Assets web
‚îÇ   ‚îú‚îÄ‚îÄ static/
‚îÇ   ‚îî‚îÄ‚îÄ templates/
‚îî‚îÄ‚îÄ docs/                  # Documentation
    ‚îî‚îÄ‚îÄ README.md
```

### Exemple concret
```
calculatrice/
‚îú‚îÄ‚îÄ go.mod
‚îú‚îÄ‚îÄ main.go                # Point d'entr√©e
‚îú‚îÄ‚îÄ internal/
‚îÇ   ‚îú‚îÄ‚îÄ operations/        # Package operations
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ basic.go       # +, -, *, /
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ advanced.go    # sin, cos, log
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ operations_test.go
‚îÇ   ‚îî‚îÄ‚îÄ ui/                # Package ui
‚îÇ       ‚îú‚îÄ‚îÄ console.go
‚îÇ       ‚îî‚îÄ‚îÄ web.go
‚îî‚îÄ‚îÄ pkg/
    ‚îî‚îÄ‚îÄ calculator/        # API publique
        ‚îî‚îÄ‚îÄ calculator.go
```

## Cr√©ation et utilisation de packages

### Package simple : mathutils
Cr√©ons un package utilitaire pour les math√©matiques.

**pkg/mathutils/mathutils.go**
```go
package mathutils

import "math"

// Fonctions export√©es (commencent par une majuscule)
func Max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func Min(a, b int) int {
    if a < b {
        return a
    }
    return b
}

func Moyenne(nombres ...float64) float64 {
    if len(nombres) == 0 {
        return 0
    }
    
    var somme float64
    for _, n := range nombres {
        somme += n
    }
    return somme / float64(len(nombres))
}

func EstPremier(n int) bool {
    if n < 2 {
        return false
    }
    
    for i := 2; i <= int(math.Sqrt(float64(n))); i++ {
        if n%i == 0 {
            return false
        }
    }
    return true
}

// Variables export√©es
const PI = 3.14159265359

// Variables non export√©es (priv√©es)
var precision = 6

// Fonctions non export√©es (priv√©es)
func arrondir(f float64) float64 {
    return math.Round(f*math.Pow10(precision)) / math.Pow10(precision)
}
```

### Utilisation du package
**main.go**
```go
package main

import (
    "fmt"
    
    // Import de notre package local
    "monprojet/pkg/mathutils"
)

func main() {
    // Utilisation des fonctions export√©es
    fmt.Printf("Max(10, 20) = %d\n", mathutils.Max(10, 20))
    fmt.Printf("Min(10, 20) = %d\n", mathutils.Min(10, 20))
    fmt.Printf("Moyenne = %.2f\n", mathutils.Moyenne(1, 2, 3, 4, 5))
    
    // Utilisation des constantes
    fmt.Printf("PI = %.5f\n", mathutils.PI)
    
    // Test de nombre premier
    for i := 2; i <= 20; i++ {
        if mathutils.EstPremier(i) {
            fmt.Printf("%d est premier\n", i)
        }
    }
}
```

## Imports et alias

### Types d'imports
```go
package main

import (
    // Import standard
    "fmt"
    "time"
    
    // Import avec alias
    f "fmt"
    
    // Import pour les effets de bord seulement
    _ "github.com/lib/pq"  // Initialise le driver PostgreSQL
    
    // Import avec point (d√©conseill√© g√©n√©ralement)
    . "math"  // Permet d'utiliser Sin() au lieu de math.Sin()
    
    // Imports de packages locaux
    "monprojet/internal/auth"
    "monprojet/pkg/utils"
    
    // Imports de packages externes
    "github.com/gorilla/mux"
    "github.com/sirupsen/logrus"
)

func main() {
    // Utilisation normale
    fmt.Println("Hello")
    
    // Avec alias
    f.Println("Hello avec alias")
    
    // Avec import point
    result := Sin(1.0)  // Au lieu de math.Sin(1.0)
    
    // Packages externes
    router := mux.NewRouter()
    logrus.Info("Application d√©marr√©e")
}
```

### Gestion des imports inutilis√©s
```go
package main

import (
    "fmt"
    _ "unused/package"  // Import pour les effets de bord
)

var _ = fmt.Sprintf  // Astuce pour √©viter "imported and not used"

func main() {
    // Si fmt n'√©tait pas utilis√©, on aurait une erreur de compilation
}
```

## Go Modules

### Initialisation d'un module
```bash
# Cr√©er un nouveau module
go mod init github.com/username/monprojet

# Structure du go.mod g√©n√©r√©
```

**go.mod**
```go
module github.com/username/monprojet

go 1.21

require (
    github.com/gorilla/mux v1.8.0
    github.com/sirupsen/logrus v1.9.3
)

require (
    github.com/gorilla/securecookie v1.1.1 // indirect
    golang.org/x/sys v0.0.0-20220715151400-c0bba94af5f8 // indirect
)
```

### Gestion des d√©pendances
```bash
# Ajouter une d√©pendance
go get github.com/gorilla/mux

# Ajouter une version sp√©cifique
go get github.com/gorilla/mux@v1.8.0

# Mettre √† jour toutes les d√©pendances
go get -u ./...

# Nettoyer les d√©pendances inutilis√©es
go mod tidy

# T√©l√©charger les d√©pendances
go mod download

# Cr√©er un vendor directory
go mod vendor
```

### Versions et compatibilit√©
```bash
# Versions s√©mantiques
go get example.com/pkg@v1.2.3    # Version exacte
go get example.com/pkg@v1.2      # Derni√®re patch de v1.2
go get example.com/pkg@v1        # Derni√®re minor de v1
go get example.com/pkg@latest    # Derni√®re version

# Versions de d√©veloppement
go get example.com/pkg@main      # Branche main
go get example.com/pkg@commit    # Commit sp√©cifique
```

## Packages internes et externes

### Package internal (priv√©)
```
monprojet/
‚îú‚îÄ‚îÄ internal/
‚îÇ   ‚îî‚îÄ‚îÄ auth/
‚îÇ       ‚îî‚îÄ‚îÄ auth.go       # Accessible seulement dans monprojet
‚îî‚îÄ‚îÄ external/
    ‚îî‚îÄ‚îÄ some_other_project/
        ‚îî‚îÄ‚îÄ main.go       # Ne peut PAS importer monprojet/internal/auth
```

**internal/auth/auth.go**
```go
package auth

import (
    "errors"
    "time"
)

type User struct {
    ID       int
    Username string
    Role     string
}

func AuthenticateUser(username, password string) (*User, error) {
    // Logique d'authentification
    if username == "" || password == "" {
        return nil, errors.New("identifiants manquants")
    }
    
    // Simulation d'une v√©rification
    if username == "admin" && password == "secret" {
        return &User{
            ID:       1,
            Username: username,
            Role:     "admin",
        }, nil
    }
    
    return nil, errors.New("identifiants invalides")
}

func GenerateToken(user *User) string {
    // Simulation de g√©n√©ration de token
    return fmt.Sprintf("token_%s_%d", user.Username, time.Now().Unix())
}
```

### Package public dans pkg/
**pkg/calculator/calculator.go**
```go
package calculator

import "math"

type Calculator struct {
    precision int
}

func New(precision int) *Calculator {
    return &Calculator{precision: precision}
}

func (c *Calculator) Add(a, b float64) float64 {
    return c.round(a + b)
}

func (c *Calculator) Subtract(a, b float64) float64 {
    return c.round(a - b)
}

func (c *Calculator) Multiply(a, b float64) float64 {
    return c.round(a * b)
}

func (c *Calculator) Divide(a, b float64) (float64, error) {
    if b == 0 {
        return 0, errors.New("division par z√©ro")
    }
    return c.round(a / b), nil
}

func (c *Calculator) Power(base, exp float64) float64 {
    return c.round(math.Pow(base, exp))
}

func (c *Calculator) round(f float64) float64 {
    if c.precision <= 0 {
        return f
    }
    factor := math.Pow10(c.precision)
    return math.Round(f*factor) / factor
}

// Fonctions utilitaires export√©es
func IsEven(n int) bool {
    return n%2 == 0
}

func IsOdd(n int) bool {
    return !IsEven(n)
}
```

## Package avec init()

### Fonction d'initialisation
```go
package database

import (
    "database/sql"
    "log"
    
    _ "github.com/lib/pq"  // Import pour l'effet de bord
)

var db *sql.DB

// init() est appel√©e automatiquement √† l'import du package
func init() {
    log.Println("Initialisation du package database")
    
    var err error
    db, err = sql.Open("postgres", "postgres://localhost/mydb")
    if err != nil {
        log.Fatal("Erreur de connexion √† la base de donn√©es:", err)
    }
    
    if err = db.Ping(); err != nil {
        log.Fatal("Base de donn√©es inaccessible:", err)
    }
    
    log.Println("Connexion √† la base de donn√©es √©tablie")
}

// Ordre d'ex√©cution des init() :
// 1. Variables globales
// 2. init() des packages import√©s (r√©cursivement)
// 3. init() du package courant
// 4. main() si c'est le package main
```

### Exemple complet avec init()
**pkg/config/config.go**
```go
package config

import (
    "encoding/json"
    "log"
    "os"
)

type AppConfig struct {
    Port     int    `json:"port"`
    Database string `json:"database"`
    LogLevel string `json:"log_level"`
}

var Config *AppConfig

func init() {
    Config = &AppConfig{
        Port:     8080,
        Database: "localhost:5432",
        LogLevel: "info",
    }
    
    // Charger depuis un fichier si il existe
    if file, err := os.Open("config.json"); err == nil {
        defer file.Close()
        
        decoder := json.NewDecoder(file)
        if err := decoder.Decode(Config); err != nil {
            log.Printf("Erreur lors du chargement de config.json: %v", err)
        } else {
            log.Println("Configuration charg√©e depuis config.json")
        }
    }
    
    // Surcharger avec les variables d'environnement
    if port := os.Getenv("APP_PORT"); port != "" {
        // Parsing et assignation...
    }
}

func (c *AppConfig) IsProduction() bool {
    return c.LogLevel == "error" || c.LogLevel == "warn"
}
```

## Documentation des packages

### Commentaires de documentation
```go
// Package mathutils fournit des utilitaires math√©matiques couramment utilis√©s.
//
// Ce package inclut des fonctions pour les op√©rations de base, les statistiques
// et la v√©rification de propri√©t√©s math√©matiques comme les nombres premiers.
//
// Exemple d'utilisation :
//
//    import "monprojet/pkg/mathutils"
//
//    max := mathutils.Max(10, 20)
//    moyenne := mathutils.Moyenne(1, 2, 3, 4, 5)
//    premier := mathutils.EstPremier(17)
//
package mathutils

import "math"

// Max retourne le plus grand des deux entiers fournis.
//
// Cette fonction compare deux entiers et retourne la valeur maximale.
// Elle g√®re correctement les nombres n√©gatifs.
//
// Exemple :
//    result := Max(-5, 3)  // retourne 3
func Max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

// Statistiques repr√©sente un ensemble de mesures statistiques.
//
// Cette structure contient les principaux indicateurs statistiques
// calcul√©s √† partir d'un ensemble de donn√©es num√©riques.
type Statistiques struct {
    // Moyenne arithm√©tique des valeurs
    Moyenne float64
    
    // Valeur minimale trouv√©e
    Min float64
    
    // Valeur maximale trouv√©e  
    Max float64
    
    // Nombre total de valeurs
    Count int
}

// CalculerStatistiques analyse un ensemble de nombres et retourne
// les statistiques de base.
//
// Si aucun nombre n'est fourni, retourne des statistiques avec
// toutes les valeurs √† z√©ro.
func CalculerStatistiques(nombres ...float64) Statistiques {
    if len(nombres) == 0 {
        return Statistiques{}
    }
    
    stats := Statistiques{
        Min:   nombres[0],
        Max:   nombres[0],
        Count: len(nombres),
    }
    
    var somme float64
    for _, n := range nombres {
        somme += n
        if n < stats.Min {
            stats.Min = n
        }
        if n > stats.Max {
            stats.Max = n
        }
    }
    
    stats.Moyenne = somme / float64(len(nombres))
    return stats
}
```

### G√©n√©ration de documentation
```bash
# G√©n√©rer la documentation HTML
go doc -http=:6060

# Afficher la documentation d'un package
go doc mathutils

# Afficher la documentation d'une fonction sp√©cifique
go doc mathutils.Max

# Documentation compl√®te
go doc -all mathutils
```

## Exemples pratiques

### Exercice 1 : Package de validation
**pkg/validation/validation.go**
```go
package validation

import (
    "errors"
    "regexp"
    "strings"
)

// Validator repr√©sente une fonction de validation
type Validator func(string) error

// Result contient le r√©sultat de validation
type Result struct {
    Valid  bool
    Errors []string
}

// Engine moteur de validation
type Engine struct {
    rules map[string][]Validator
}

// NewEngine cr√©e un nouveau moteur de validation
func NewEngine() *Engine {
    return &Engine{
        rules: make(map[string][]Validator),
    }
}

// AddRule ajoute une r√®gle de validation pour un champ
func (e *Engine) AddRule(field string, validators ...Validator) *Engine {
    e.rules[field] = append(e.rules[field], validators...)
    return e
}

// Validate valide un ensemble de donn√©es
func (e *Engine) Validate(data map[string]string) map[string]Result {
    results := make(map[string]Result)
    
    for field, validators := range e.rules {
        result := Result{Valid: true}
        value := data[field]
        
        for _, validator := range validators {
            if err := validator(value); err != nil {
                result.Valid = false
                result.Errors = append(result.Errors, err.Error())
            }
        }
        
        results[field] = result
    }
    
    return results
}

// Validators pr√©d√©finis

// Required v√©rifie qu'un champ n'est pas vide
func Required() Validator {
    return func(value string) error {
        if strings.TrimSpace(value) == "" {
            return errors.New("ce champ est requis")
        }
        return nil
    }
}

// MinLength v√©rifie la longueur minimale
func MinLength(min int) Validator {
    return func(value string) error {
        if len(value) < min {
            return fmt.Errorf("doit contenir au moins %d caract√®res", min)
        }
        return nil
    }
}

// MaxLength v√©rifie la longueur maximale
func MaxLength(max int) Validator {
    return func(value string) error {
        if len(value) > max {
            return fmt.Errorf("ne doit pas d√©passer %d caract√®res", max)
        }
        return nil
    }
}

// Email v√©rifie le format email
func Email() Validator {
    emailRegex := regexp.MustCompile(`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`)
    return func(value string) error {
        if value != "" && !emailRegex.MatchString(value) {
            return errors.New("format d'email invalide")
        }
        return nil
    }
}

// Pattern v√©rifie un motif regex
func Pattern(pattern, message string) Validator {
    regex := regexp.MustCompile(pattern)
    return func(value string) error {
        if value != "" && !regex.MatchString(value) {
            return errors.New(message)
        }
        return nil
    }
}
```

### Utilisation du package validation
**main.go**
```go
package main

import (
    "fmt"
    
    "monprojet/pkg/validation"
)

func main() {
    // Cr√©er le moteur de validation
    validator := validation.NewEngine()
    
    // Configurer les r√®gles
    validator.
        AddRule("nom", validation.Required(), validation.MinLength(2)).
        AddRule("email", validation.Required(), validation.Email()).
        AddRule("password", 
            validation.Required(), 
            validation.MinLength(8),
            validation.Pattern(`[A-Z]`, "doit contenir au moins une majuscule"),
            validation.Pattern(`[0-9]`, "doit contenir au moins un chiffre"),
        )
    
    // Donn√©es √† valider
    userData := map[string]string{
        "nom":      "Alice",
        "email":    "alice@example.com",
        "password": "Password123",
    }
    
    // Validation
    results := validator.Validate(userData)
    
    // Affichage des r√©sultats
    fmt.Println("=== R√©sultats de validation ===")
    for field, result := range results {
        if result.Valid {
            fmt.Printf("‚úÖ %s: valide\n", field)
        } else {
            fmt.Printf("‚ùå %s: invalide\n", field)
            for _, err := range result.Errors {
                fmt.Printf("   - %s\n", err)
            }
        }
    }
}
```

### Exercice 2 : Package de logging
**pkg/logger/logger.go**
```go
package logger

import (
    "fmt"
    "io"
    "log"
    "os"
    "runtime"
    "strings"
    "time"
)

type Level int

const (
    DEBUG Level = iota
    INFO
    WARN
    ERROR
    FATAL
)

func (l Level) String() string {
    switch l {
    case DEBUG:
        return "DEBUG"
    case INFO:
        return "INFO"
    case WARN:
        return "WARN"
    case ERROR:
        return "ERROR"
    case FATAL:
        return "FATAL"
    default:
        return "UNKNOWN"
    }
}

type Logger struct {
    level  Level
    output io.Writer
    logger *log.Logger
}

// NewLogger cr√©e un nouveau logger
func NewLogger(level Level, output io.Writer) *Logger {
    return &Logger{
        level:  level,
        output: output,
        logger: log.New(output, "", 0),
    }
}

// NewConsoleLogger cr√©e un logger pour la console
func NewConsoleLogger(level Level) *Logger {
    return NewLogger(level, os.Stdout)
}

// NewFileLogger cr√©e un logger pour un fichier
func NewFileLogger(level Level, filename string) (*Logger, error) {
    file, err := os.OpenFile(filename, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
    if err != nil {
        return nil, err
    }
    return NewLogger(level, file), nil
}

func (l *Logger) log(level Level, format string, args ...interface{}) {
    if level < l.level {
        return
    }
    
    // Obtenir les informations d'appel
    _, file, line, ok := runtime.Caller(2)
    caller := "unknown"
    if ok {
        parts := strings.Split(file, "/")
        if len(parts) > 0 {
            caller = fmt.Sprintf("%s:%d", parts[len(parts)-1], line)
        }
    }
    
    // Formatter le message
    timestamp := time.Now().Format("2006-01-02 15:04:05")
    message := fmt.Sprintf(format, args...)
    
    logLine := fmt.Sprintf("[%s] %s %s - %s", 
        timestamp, level.String(), caller, message)
    
    l.logger.Println(logLine)
    
    // Fatal arr√™te le programme
    if level == FATAL {
        os.Exit(1)
    }
}

func (l *Logger) Debug(format string, args ...interface{}) {
    l.log(DEBUG, format, args...)
}

func (l *Logger) Info(format string, args ...interface{}) {
    l.log(INFO, format, args...)
}

func (l *Logger) Warn(format string, args ...interface{}) {
    l.log(WARN, format, args...)
}

func (l *Logger) Error(format string, args ...interface{}) {
    l.log(ERROR, format, args...)
}

func (l *Logger) Fatal(format string, args ...interface{}) {
    l.log(FATAL, format, args...)
}

// Logger global par d√©faut
var defaultLogger = NewConsoleLogger(INFO)

// Fonctions globales
func Debug(format string, args ...interface{}) {
    defaultLogger.Debug(format, args...)
}

func Info(format string, args ...interface{}) {
    defaultLogger.Info(format, args...)
}

func Warn(format string, args ...interface{}) {
    defaultLogger.Warn(format, args...)
}

func Error(format string, args ...interface{}) {
    defaultLogger.Error(format, args...)
}

func Fatal(format string, args ...interface{}) {
    defaultLogger.Fatal(format, args...)
}

func SetLevel(level Level) {
    defaultLogger.level = level
}
```

## Bonnes pratiques

### 1. Nommage des packages
```go
// ‚úÖ Bon - noms courts et descriptifs
package http
package json
package auth
package user

// ‚ùå √âvitez - noms trop g√©n√©riques ou longs
package utils
package helpers
package authenticationandauthorization
```

### 2. Organisation des fichiers
```go
// ‚úÖ Un fichier par type/concept principal
user.go          // type User et m√©thodes
user_service.go  // logique m√©tier
user_handler.go  // handlers HTTP
user_test.go     // tests

// ‚ùå √âvitez les gros fichiers fourre-tout
everything.go
```

### 3. API publique claire
```go
// ‚úÖ Exportez seulement ce qui est n√©cessaire
func PublicFunction() {}     // Export√©e
func privateFunction() {}    // Priv√©e

type PublicStruct struct {
    PublicField  string      // Export√©
    privateField string      // Priv√©
}
```

### 4. Gestion des erreurs
```go
// ‚úÖ Retournez des erreurs appropri√©es
func LoadConfig(filename string) (*Config, error) {
    if filename == "" {
        return nil, errors.New("nom de fichier requis")
    }
    // ...
}
```

## Prochaine √©tape

Parfait ! Vous ma√Ætrisez maintenant :
- ‚úÖ Organisation des packages et structure de projet
- ‚úÖ Imports, exports et visibilit√©
- ‚úÖ Go modules et gestion des d√©pendances
- ‚úÖ Packages internes vs externes
- ‚úÖ Documentation et bonnes pratiques

üëâ **[D√©couvrons la concurrence avec les goroutines](/concurrence)**

---

> **üí° Astuce** : Un bon package a une responsabilit√© claire, une API simple et une documentation compl√®te. Pensez √† vos packages comme des bo√Ætes √† outils sp√©cialis√©es !