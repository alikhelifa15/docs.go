---
title: G√©n√©riques en Go (1.18+)
description: Guide complet sur les types et fonctions g√©n√©riques en Go
---

# üß© G√©n√©riques en Go

## Introduction

Les g√©n√©riques ont √©t√© introduits dans Go 1.18, apportant une nouvelle dimension au langage. Cette fonctionnalit√© permet d'√©crire du code plus flexible et r√©utilisable sans sacrifier la s√©curit√© de type.

## Pourquoi les g√©n√©riques ?

Avant Go 1.18, pour √©crire des fonctions travaillant avec diff√©rents types, on devait souvent :
- √âcrire plusieurs versions de la m√™me fonction
- Utiliser le type `interface{}` et effectuer des assertions de type
- G√©n√©rer du code via des outils externes

## Types de param√®tres

### D√©claration de contraintes

```go
type Number interface {
    ~int | ~float64 | ~float32
}
```

### Fonctions g√©n√©riques

```go
// Fonction g√©n√©rique pour trouver le minimum entre deux valeurs
func Min[T Number](a, b T) T {
    if a < b {
        return a
    }
    return b
}

// Utilisation
minInt := Min(3, 7)        // 3
minFloat := Min(3.14, 2.71) // 2.71
```

## Types g√©n√©riques

### D√©finition d'un type g√©n√©rique

```go
// Stack g√©n√©rique
type Stack[T any] struct {
    items []T
}

func (s *Stack[T]) Push(item T) {
    s.items = append(s.items, item)
}

func (s *Stack[T]) Pop() T {
    if len(s.items) == 0 {
        panic("stack is empty")
    }
    item := s.items[len(s.items)-1]
    s.items = s.items[:len(s.items)-1]
    return item
}

// Utilisation
var intStack Stack[int]
intStack.Push(1)
intStack.Push(2)
fmt.Println(intStack.Pop()) // Affiche 2
```

## Contraintes int√©gr√©es

Go fournit plusieurs contraintes pr√©d√©finies dans le package `constraints` :

```go
import "golang.org/x/exp/constraints"

// Contraintes utiles :
// - constraints.Ordered  : types ordonn√©s (<, >, <=, >=)
// - constraints.Integer  : tous les entiers
// - constraints.Float    : tous les flottants
// - constraints.Complex  : nombres complexes
// - constraints.Unsigned : entiers non sign√©s
```

## Bonnes pratiques

1. **Ne pas abuser des g√©n√©riques** : Utilisez-les quand ils simplifient r√©ellement le code
2. **Nommez clairement les param√®tres de type** : Utilisez des noms descriptifs comme `T`, `K`, `V`
3. **Documentez les contraintes** : Expliquez les attentes sur les types g√©n√©riques
4. **√âvitez les g√©n√©riques pour les m√©thodes** : Pr√©f√©rez les fonctions g√©n√©riques aux m√©thodes g√©n√©riques quand c'est possible

## Exemple complet : Map, Filter, Reduce

```go
func Map[T any, U any](s []T, f func(T) U) []U {
    result := make([]U, len(s))
    for i, v := range s {
        result[i] = f(v)
    }
    return result
}

func Filter[T any](s []T, f func(T) bool) []T {
    var result []T
    for _, v := range s {
        if f(v) {
            result = append(result, v)
        }
    }
    return result
}

func Reduce[T any, U any](s []T, init U, f func(U, T) U) U {
    result := init
    for _, v := range s {
        result = f(result, v)
    }
    return result
}

// Utilisation
numbers := []int{1, 2, 3, 4, 5}

// Carr√© des nombres
squares := Map(numbers, func(n int) int {
    return n * n
})

// Nombres pairs
evens := Filter(numbers, func(n int) bool {
    return n%2 == 0
})

// Somme des carr√©s
sum := Reduce(squares, 0, func(a, b int) int {
    return a + b
})
```

## Limitations

1. Pas de m√©thodes g√©n√©riques (seulement les types et fonctions)
2. Pas de sp√©cialisation de type
3. Pas de m√©taprogrammation

## Quand utiliser les g√©n√©riques ?

- Pour les structures de donn√©es g√©n√©riques (piles, files, arbres, etc.)
- Pour les algorithmes qui fonctionnent sur plusieurs types num√©riques
- Pour √©viter la duplication de code similaire pour diff√©rents types

## Exercices

1. Impl√©mentez une file d'attente (queue) g√©n√©rique
2. Cr√©ez une fonction `Contains` g√©n√©rique qui v√©rifie si une valeur est pr√©sente dans une slice
3. Impl√©mentez une fonction `Keys` qui retourne les cl√©s d'une map sous forme de slice

## Ressources suppl√©mentaires

- [Go Blog: Introduction to Generics](https://go.dev/blog/intro-generics)
- [Go 1.18 Release Notes](https://golang.org/doc/go1.18)
- [Go Generics by Example](https://go.dev/blog/generics-proposal)

---

Avec cette nouvelle section, votre documentation couvre maintenant une fonctionnalit√© majeure de Go moderne. Les g√©n√©riques sont particuli√®rement utiles pour √©crire du code plus s√ªr et plus r√©utilisable tout en maintenant les performances de Go.
